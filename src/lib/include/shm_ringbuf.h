/**
 *  Library for creating a shared memory ring buffer that can be used for the transmission of log messages 
 *  between a single writer and multiple readers. For more detail, see thesis chapter 3
 *  
 * 
 * 
 * 
 * 
*/

//#pragma once
#ifndef _SHMRBUF_H
#define _SHMRBUF_H

#pragma once
#include <stdint.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdatomic.h>
#include <unistd.h>
#include <fcntl.h>
#include <threads.h>

#include <io_ipc.h>

#define SHMRBUF_PERM 0644 // File permission on the shared memory segment

// Flags
/** Enables reattachment to an existing buffer for the writer (writer only) */
#define SHMRBUF_REATT 0x01 // Enables reattachment to an existing buffer for the writer (writer only)
#define SHMRBUF_FRCAT 0x02 // No current purpose
#define SHMRBUF_OVWR 0x04 // Enables overwrite for write operations to the buffer (writer only)
#define SHMRBUF_NOREG 0x08 // Enables a reader to attach to the buffer, without registering as a reader (for inspection purposes) (reader only)
#define SHMRBUF_RESET 0x016 // Resets the read pointers in all segments to the position of the writer, when reattaching as a reader

/**
 * @brief Contains all necessary information for the writer process
 *
 */
struct shmrbuf_writer_arg_t {
  /** System V IPC key (generated by ftok) */
  const char *shm_key;
  /** size of a line entry in bytes @todo defined twice in global header? */
  uint16_t line_size;
  /** number of entries in each ring buffer/segment */
  uint32_t line_count;
  /** number of segments (corresponds to the number of writer threads) */
  uint8_t segment_count;
  /** number of approved reading processes */
  uint8_t reader_count;
  /** pointer to struct with global information for shared memory */
  struct shmrbuf_global_hdr_t *global_hdr;
  /** pointer to struct with information on write synchronization */
  struct shmrbuf_seg_whdr_t *segment_hdrs;
  /** flags for read/write options (see above), are set by bit masks */
  int flags;
  /** shmget returns shared memory identifier of the System V shared memory
   * segment assiciated with shm_key */
  int shm_id;
};

/**
 * @brief Contains all necessary information for the reader process
 *
 */
struct shmrbuf_reader_arg_t {
  /** System V IPC key (generated by ftok) */
  const char *shm_key;
  /** shmget returns shared memory identifier of the System V shared memory
   * segment assiciated with shm_key */
  int shm_id;
  /** flags for read/write options (see above), are set by bit masks */
  int flags;
  /** ID of the reader process, counting from 0 to n readers */
  uint8_t reader_id;
  /** Pointer to global header struct */
  struct shmrbuf_global_hdr_t *global_hdr;
  /** pointer to struct with information on read synchronization */
  struct shmrbuf_seg_rhdr_t *segment_hdrs;
};

/**
 * @brief Contains all information of the global header
 *
 */
struct shmrbuf_global_hdr_t {
  /** simple checksum to detect corrupted shared memory segments */
  uint32_t checksum;
  /** number of segments (corresponds to the number of writer threads) */
  uint8_t segment_count;
  /** number of approved reading processes */
  uint8_t reader_count;
  /** size of a line entry in bytes @todo defined twice in global header? */
  uint16_t line_size;
  /** number of elements in each segment */
  uint32_t line_count;
  /** allows overwriting by writer of values not yet read by the reader */
  bool overwrite;
  /** write process attached to the shared memory segment */
  atomic_bool writer_att;
  /** read process attached to the shared memory segment*/
  atomic_bool first_reader_att;
};

/**
 * @brief Contains information on reading the data and synchronizing the reader
 * threads
 *
 */
struct shmrbuf_seg_rhdr_t {
  /** indices of the read and write threads in the corresponding segment */
  atomic_uint_fast32_t *write_index, *read_index;
  /** semaphore for locking the reader thread accesses */
  pthread_mutex_t segment_lock;
  /** pointer to the starting point of the data to be read out */
  void *data;
};

/**
 * @brief Contains information on writing data to the ring buffer
 *
 */
struct shmrbuf_seg_whdr_t {
  /** indices of the read and write threads in the corresponding segment */
  atomic_uint_fast32_t *write_index, *first_reader;
  /** Pointer to the write start point in the ring buffer */
  void *data;
};

/**
 * @brief Role of the corresponding process (reader or writer)
 *
 */
enum shmrbuf_role_t {
  /** writer process correspnds to 0 */
  SHMRBUF_WRITER,
  /** reader process corresponds to 1 */
  SHMRBUF_READER
};

/**
 * @brief Possible, roles when calling shmrbuf_init or shmrbuf_finalize
 * Union data type reserves the memory for the largest data structure defined in
 * the union (in this case shrmbuf_seg_rhdr_t), but can only store one data
 * instance at a time.
 */
union shmrbuf_arg_t {
  struct shmrbuf_writer_arg_t wargs;
  struct shmrbuf_reader_arg_t rargs;
};

/**
 * @brief Creates the ringbuffer or attaches to an existing one
 *
 * @param args contains struct to either reader or writer information
 * @param role reader or writer process
 * @return int error code as defined in io_ipc.h
 */
int shmrbuf_init(union shmrbuf_arg_t *args, enum shmrbuf_role_t role);

/**
 * @brief Detaches from the ringbuffer and removes the  memory segment, if no
 * other process is attached
 *
 * @param args contains struct to either reader or writer information
 * @param role reader or writer process
 * @return int error code as defined in io_ipc.h
 */
int shmrbuf_finalize(union shmrbuf_arg_t *, enum shmrbuf_role_t role);

/**
 * @brief Writes a single line to a segment
 *
 * @param args pointer to struct of writer information
 * @param src pointer to start of the element to be written to the shared memory
 * segment
 * @param wsize size of element to be written in the shared memory segment
 * @param segment_id id of ringbuffer segment
 * @return int size of elements written in shared memory segment
 */
int shmrbuf_write(struct shmrbuf_writer_arg_t * args, 
                  void * src, uint16_t wsize, 
                  uint8_t segment_id);

/**
 * @brief Writes multiple lines to a segment
 *
 * @param args struct to writer information
 * @param iovecs vector structure with base pointer to start point and length of
 * data
 * @param vsize number of lines to be written in the shared memory segment
 * @param segment_id
 * @return int number of written lines to the shared memory segment
 */
int shmrbuf_writev(struct shmrbuf_writer_arg_t * args, 
                   struct iovec * iovecs, 
                   uint16_t vsize, 
                   uint8_t segment_id);

/**
 * @brief Reads a single line from a segment and writes it to a read buffer.
 *
 * @param args struct to reader information
 * @param rbuf void pointer to buffer into which the read line is copied
 * @param bufsize size of read buffer
 * @param segment_id id of the ringbuffer segment to be read in
 * @return int total size of the elements that were read in
 */
int shmrbuf_read(struct shmrbuf_reader_arg_t * args, 
                 void * rbuf, 
                 uint16_t bufsize, 
                 uint8_t segment_id);

/**
 * @brief Reads multiple lines from a segment and writes it to an iovev
 * structure.
 *
 * @param args struct to reader information
 * @param iovecs pointer to iovec structure
 * @param vsize number of lines to be read (is adjusted depending on the
 * position of the read and write index in the function)
 * @param bufsize buffer size into which an element is to be written. Must be at
 * least as large as line_size.
 * @param segment_id id of the ringbuffer segment to be read in
 * @return int number of lines read
 */
int shmrbuf_readv(struct shmrbuf_reader_arg_t * args, 
                  struct iovec * iovecs, 
                  uint16_t vsize, 
                  uint16_t bufsize, 
                  uint8_t segment_id);

// Reads a line from a segment ouf of a specified range.
/**
 * @brief Reads a line from shared memory segments within the specified segment
 * range.
 *
 * @details This function is helpful if there are fewer reader threads than ring
 * buffer segments, as the thread iterates over the corresponding segment area
 * in a round robin procedure and thus reads the lines evenly.
 * @param args struct to reader information
 * @param rbuf void pointer to buffer into which the read line is copied
 * @param bufsize size of read buffer
 * @param lower lower segment id, which marks the start area of the segment area
 * to be read out
 * @param upper upper segment id, which marks the end area of the segment area
 * to be read out
 * @param wsteal bool, which specifies whether rows outside the range should
 * also be read (e.g. useful if there are no elements for reading in the
 * specified range)
 * @return int number of elements read
 */
int shmrbuf_read_rng(struct shmrbuf_reader_arg_t * args, 
                     void * rbuf, 
                     uint16_t bufsize, 
                     uint8_t lower, 
                     uint8_t upper, 
                     bool * wsteal);

/** @brief Reads multiple lines from shared memory segments within the specified segment
 * range.
 * 
 * 
 * @details This function is helpful if there are fewer reader threads than ring
 * buffer segments, as the thread iterates over the corresponding segment area
 * in a round robin procedure and thus reads the lines evenly.
 * @param args struct to reader information
 * @param iovecs pointer to iovec structure 
 * @param vsize number of lines to be read (is adjusted depending on the
 * position of the read and write index in the function)
 * @param bufsize buffer size into which an element is to be written. Must be at
 * least as large as line_size.
 * @param lower lower segment id, which marks the start area of the segment area
 * to be read out 
 * @param upper upper segment id, which marks the end area of the segment area
 * to be read out  
 * @param wsteal bool, which specifies whether rows outside the range should
 * also be read (e.g. useful if there are no elements for reading in the
 * specified range)
 * @return int Cumulated number of elements in the lines read in
 */
int shmrbuf_readv_rng(struct shmrbuf_reader_arg_t * args, 
                      struct iovec * iovecs, 
                      uint16_t vsize, 
                      uint16_t bufsize, 
                      uint8_t lower, 
                      uint8_t upper, 
                      uint16_t * wsteal);

#endif
